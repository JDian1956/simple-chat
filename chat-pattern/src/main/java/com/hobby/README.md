## 1. 设计模式的六大原则

#### 开放封闭原则（Open Close Principle）

* 思想：对扩展开放，对修改关闭。
* 描述：当需求发生变化时，应通过新增代码来扩展系统的行为，而不是修改已有的代码。这样可以避免影响已有功能，提高系统的稳定性。
* 优点：
    * 提高代码可维护性，降低因修改带来的风险。
    * 支持灵活的系统扩展，适应未来的变化。

#### 里氏代换原则（Liskov Substitution Principle）

* 思想：任何基类出现的地方都可以被其子类无缝替换，而不破坏程序的正确性。
* 描述：
    * 子类可以在不改变父类行为的前提下扩展功能。
    * 不允许覆盖父类的非抽象方法，以避免继承关系被破坏。
    * 子类可以添加自己的特有方法。
* 优点：
    * 提高程序的健壮性和可扩展性。
    * 保证继承结构的合理性，避免“强盗式”继承。

#### 依赖倒转原则（Dependence Inversion Principle）

* 思想：面向接口编程，而不是面向实现编程。
* 描述：
    * 高层模块不应该依赖低层模块，两者都应该依赖于抽象（接口或抽象类）。
    * 抽象不应依赖细节，细节应依赖于抽象。
* 优点：
    * 降低模块之间的耦合度。
    * 增加系统的灵活性和可测试性。

#### 接口隔离原则（Interface Segregation Principle）

* 思想：客户端不应该依赖它不需要的接口。
* 描述：
    * 一个类对另一个类的依赖应该建立在最小的接口上。
    * 应将臃肿的接口拆分为更细粒度的接口，以满足不同客户端的需求。
* 优点：
    * 避免接口污染，提高接口的内聚性。
    * 减少不必要的实现类代码冗余。

#### 迪米特法则（最少知道原则）（Demeter Principle）

* 思想：一个对象应当对其他对象保持最少的了解。
* 描述：
    * 只与直接的朋友通信（如成员变量、方法参数、返回值等）。
    * 不要和陌生人说话，即尽量减少与其他类的耦合。
* 优点：
    * 降低类之间的耦合度。
    * 提高系统的可维护性和可读性。

#### 单一职责原则（Principle of single responsibility）

* 思想：一个类/接口/方法只负责一项职责。
* 描述：
    * 每个类或接口应只有一个引起它变化的原因。
    * 职责划分清晰，有助于提高代码的可读性和可维护性。
* 优点：
    * 降低类的复杂度。
    * 提高可读性和可测试性。
    * 减少副作用和错误的发生概率。

## 2. 单例模式（com.hobby.singleton_pattern）

#### 饿汉模式（[查看 Singleton1.java](./singleton_pattern/Singleton1.java)）

* 优点是线程安全的，只有一个实例。缺点是即使没有调用getInstance()方法，instance实例在类加载时被初始化了。

#### Singleton2 懒汉模式，非线程安全

* 判断了当instance不等于空时，才进行初始化。但是当多个线程同时执行到if(instance==null)的时候，一个线程执行完new Singleton()，其他线程也会接着执行，导致new出多个实例。

#### Singleton3 懒汉模式，线程安全

* 在getInstance()方法上增加了synchronized锁，实现只有一个线程进行实例化对象，但是instance已经被实例化过，还是只能有一个线程访问getInstance()方法，性能急剧下降。

#### Singleton4 双重检查锁定实现的单例模式（非线程安全）

* 虽然通过两次检查 instance == null 来减少同步开销， 并确保最多只会有一个线程创建实例，但由于 JVM 的指令重排序机制， 仍然存在线程安全问题。

#### Singleton5 双重检查锁模式（线程安全）

* instance对象用了volatile修饰，会禁止jvm对该对象的指令重排序，保证线程安全

#### Singleton6 使用静态内部类实现的单例模式（推荐）

* 懒加载：仅在首次调用 getInstance() 时初始化
* 线程安全：由 JVM 类加载机制保障
* 高性能：无需加锁或同步操作

#### Singleton7 枚举单例模式（推荐）

* 枚举单例模式，线程安全，性能高

## 3. 策略模式（com.hobby.strategy_pattern）

#### strategy1 基本策略模式

* 整体显得非常笨重不是很灵活，不推荐使用

#### strategy2 枚举策略模式

* 其具有代码简洁，线程安全，避免反射攻击，易于扩展的特点，但是灵活性受限，功能受限（策略逻辑复杂，枚举类可能会变得臃肿，不适合复杂的业务场景），复用性较差

#### strategy3 spring增强 策略模式（未实现）

* spring增强策略模式 相比基本策略模式更复杂，但它更适合大型项目或微服务架构中对可扩展性和可维护性要求较高的场景
* 使用场景
    * 多种支付方式（支付宝、微信、银联等）
    * 不同地区的促销策略
    * 多渠道消息发送（短信、邮件、站内信等）
    * 动态路由处理（根据请求参数决定执行逻辑）

## 4. 工厂模式（com.hobby.factory_pattern）

#### 简单工厂模式，也称为 静态工厂方法模式（com.hobby.factory_pattern.simple_factory）

* 简单工厂模式（Simple Factory Pattern）是一种创建型设计模式，它通过一个工厂类来统一创建对象的实例，从而解耦调用方与具体类之间的依赖关系。
* 通常包含以下三个角色：
  * 抽象产品（Product）：定义产品的公共接口或抽象类
  * 具体产品（Concrete Product）：实现接口的具体类，是工厂创建的对象
  * 工厂类（Factory）：包含一个静态方法，根据参数决定创建哪个具体产品
* 优点：
  * 解耦：调用方不依赖具体类，只依赖接口和工厂
  * 集中管理：所有对象创建逻辑集中在一个类中，便于维护
  * 易于扩展：新增类别只需修改工厂类（新增 case 分支）
* 缺点：
  * 违反开闭原则：新增类别需要修改工厂类，不符合“对修改关闭”
  * 工厂职责过重：所有创建逻辑都在一个类中，容易变得臃肿
  * 不属于GoF 23种设计模式：是一种简化版的工厂模式，不是标准模式


