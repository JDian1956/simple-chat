## 1. 设计模式的六大原则

#### 开放封闭原则（Open Close Principle）

* 思想：对扩展开放，对修改关闭。
* 描述：当需求发生变化时，应通过新增代码来扩展系统的行为，而不是修改已有的代码。这样可以避免影响已有功能，提高系统的稳定性。
* 优点：
    * 提高代码可维护性，降低因修改带来的风险。
    * 支持灵活的系统扩展，适应未来的变化。

#### 里氏代换原则（Liskov Substitution Principle）

* 思想：任何基类出现的地方都可以被其子类无缝替换，而不破坏程序的正确性。
* 描述：
    * 子类可以在不改变父类行为的前提下扩展功能。
    * 不允许覆盖父类的非抽象方法，以避免继承关系被破坏。
    * 子类可以添加自己的特有方法。
* 优点：
    * 提高程序的健壮性和可扩展性。
    * 保证继承结构的合理性，避免“强盗式”继承。

#### 依赖倒转原则（Dependence Inversion Principle）

* 思想：面向接口编程，而不是面向实现编程。
* 描述：
    * 高层模块不应该依赖低层模块，两者都应该依赖于抽象（接口或抽象类）。
    * 抽象不应依赖细节，细节应依赖于抽象。
* 优点：
    * 降低模块之间的耦合度。
    * 增加系统的灵活性和可测试性。

#### 接口隔离原则（Interface Segregation Principle）

* 思想：客户端不应该依赖它不需要的接口。
* 描述：
    * 一个类对另一个类的依赖应该建立在最小的接口上。
    * 应将臃肿的接口拆分为更细粒度的接口，以满足不同客户端的需求。
* 优点：
    * 避免接口污染，提高接口的内聚性。
    * 减少不必要的实现类代码冗余。

#### 迪米特法则（最少知道原则）（Demeter Principle）

* 思想：一个对象应当对其他对象保持最少的了解。
* 描述：
    * 只与直接的朋友通信（如成员变量、方法参数、返回值等）。
    * 不要和陌生人说话，即尽量减少与其他类的耦合。
* 优点：
    * 降低类之间的耦合度。
    * 提高系统的可维护性和可读性。

#### 单一职责原则（Principle of single responsibility）

* 思想：一个类/接口/方法只负责一项职责。
* 描述：
    * 每个类或接口应只有一个引起它变化的原因。
    * 职责划分清晰，有助于提高代码的可读性和可维护性。
* 优点：
    * 降低类的复杂度。
    * 提高可读性和可测试性。
    * 减少副作用和错误的发生概率。

## 2. 单例模式（[查看示例](./singleton_pattern)）

#### 饿汉模式（[查看示例](./singleton_pattern/Singleton1.java)）

* 优点是线程安全的，只有一个实例。缺点是即使没有调用getInstance()方法，instance实例在类加载时被初始化了。

#### 懒汉模式，非线程安全（[查看示例](./singleton_pattern/Singleton2.java)）

* 判断了当instance不等于空时，才进行初始化。但是当多个线程同时执行到if(instance==null)的时候，一个线程执行完new Singleton()，其他线程也会接着执行，导致new出多个实例。

#### 懒汉模式，线程安全（[查看示例](./singleton_pattern/Singleton3.java)）

* 在getInstance()方法上增加了synchronized锁，实现只有一个线程进行实例化对象，但是instance已经被实例化过，还是只能有一个线程访问getInstance()方法，性能急剧下降。

#### 双重检查锁定实现的单例模式，非线程安全（[查看示例](./singleton_pattern/Singleton4.java)）

* 虽然通过两次检查 instance == null 来减少同步开销， 并确保最多只会有一个线程创建实例，但由于 JVM 的指令重排序机制， 仍然存在线程安全问题。

#### 双重检查锁模式，线程安全（[查看示例](./singleton_pattern/Singleton5.java)）

* instance对象用了volatile修饰，会禁止jvm对该对象的指令重排序，保证线程安全

#### 使用静态内部类实现的单例模式，推荐（[查看示例](./singleton_pattern/Singleton6.java)）

* 懒加载：仅在首次调用 getInstance() 时初始化
* 线程安全：由 JVM 类加载机制保障
* 高性能：无需加锁或同步操作

#### 枚举单例模式，推荐（[查看示例](./singleton_pattern/Singleton7.java)）

* 枚举单例模式，线程安全，性能高

## 3. 策略模式（[查看示例](./strategy_pattern)）

#### 基本策略模式（[查看示例](./strategy_pattern/base_strategy/BaseStrategyDemo.java)）

* 整体显得非常笨重不是很灵活，不推荐使用

#### 枚举策略模式（[查看示例](./strategy_pattern/enum_strategy/EnumStrategyPatternDemo.java)）

* 其具有代码简洁，线程安全，避免反射攻击，易于扩展的特点，但是灵活性受限，功能受限（策略逻辑复杂，枚举类可能会变得臃肿，不适合复杂的业务场景），复用性较差

#### spring增强 策略模式（未实现）（[查看示例](./strategy_pattern/spring_enhance_strategy)）

* spring增强策略模式 相比基本策略模式更复杂，但它更适合大型项目或微服务架构中对可扩展性和可维护性要求较高的场景
* 使用场景
    * 多种支付方式（支付宝、微信、银联等）
    * 不同地区的促销策略
    * 多渠道消息发送（短信、邮件、站内信等）
    * 动态路由处理（根据请求参数决定执行逻辑）

## 4. 工厂模式（[查看示例](./factory_pattern))

#### 简单工厂模式（Simple Factory Pattern），也称为静态工厂方法模式（[查看示例](./factory_pattern/simple_factory/SimpleFactoryDemo.java))

* 简单工厂模式是一种创建型设计模式，它通过一个工厂类来统一创建对象的实例，从而解耦调用方与具体类之间的依赖关系。
* 核心结构：
  * 抽象产品（Product）：定义产品的公共接口或抽象类
  * 具体产品（Concrete Product）：抽象产品的具体实现
  * 工厂类（Factory）：包含一个静态方法，根据参数决定创建哪个具体产品
* 优点：
  * 解耦：调用方不依赖具体类，只依赖接口和工厂
  * 集中管理：所有对象创建逻辑集中在一个类中，便于维护
  * 易于扩展：新增类别只需修改工厂类（新增 case 分支）
* 缺点：
  * 违反开闭原则：新增类别需要修改工厂类，不符合“对修改关闭”
  * 工厂职责过重：所有创建逻辑都在一个类中，容易变得臃肿
  * 不属于GoF 23种设计模式：是一种简化版的工厂模式，不是标准模式

#### 工厂方法模式（Factory Method Pattern）（[查看示例](./factory_pattern/factory_method/FactoryMethodDemo.java)）

* 工厂方法模式是一种创建型设计模式，它通过定义抽象工厂类来创建抽象产品类的实例。抽象工厂类定义了创建抽象产品类的方法，而具体工厂类则实现了抽象工厂类中的方法，并返回具体产品类的实例。
* 核心结构:
  * 抽象产品（Product）：定义产品的公共接口或抽象类
  * 具体产品（Concrete Product）：产品的具体实现类
  * 抽象工厂（Factory）：定义工厂的公共接口或抽象类
  * 具体工厂（Concrete Factory）：工厂的具体实现类，继承抽象工厂类，并实现抽象工厂类中的方法，返回具体产品类的实例
* 优点：
  * 符合开闭原则：新增产品只需新增工厂类，无需修改已有代码
  * 解耦更彻底：每个工厂只负责一种产品，职责单一
  * 更具扩展性：支持多层级的产品族（如不同地区、不同类型的支付方式）
  * 更容易维护：各个工厂独立，便于测试和替换
* 缺点：
  * 类数量增加：每个产品都需要一个对应的工厂类，类数量成倍增长
  * 复杂度上升：对于简单场景来说，会略显复杂

#### 抽象工厂模式（Abstract Factory Pattern）（[查看示例](./factory_pattern/abstract_factory/AbstractFactoryDemo.java)）
* 抽象工厂模式是一种创建型设计模式
* 核心结构：
  * 抽象工厂（Abstract Factory）：定义一组用于创建产品的接口，如 CompanyFactory
  * 具体工厂（Concrete Factory）：实现抽象工厂的方法，返回具体产品实例，如 AppleCompanyFactory
  * 抽象产品（Abstract Product）：定义产品的公共接口，如 ComputerFactory, PhoneFactory
  * 具体产品（Concrete Product）：实现抽象产品的方法，具体产品实例，如 ApplePhoneProducer, MiComputerProducer
  * Client（客户端）：使用抽象工厂和抽象产品进行开发，不依赖具体实现
* 优点：
  * 封装性好：客户端不关心具体产品类，只需面向接口编程
  * 一致性保障：同一个工厂生产的系列产品保证兼容性和一致性
  * 易于扩展：新增一个品牌只需新增一个具体工厂类和具体产品类，符合开闭原则
  * 解耦：高层模块通过接口调用，不依赖具体实现类
* 缺点：
  * 复杂度高：涉及多个抽象接口和类，理解比较困难
  * 扩展困难：如新增一个新的产品类型（如耳机），必须修改抽象工厂接口，违反开闭原则
  

