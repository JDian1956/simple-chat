## 1. 设计模式的六大原则

#### 1.1 开放封闭原则（Open Close Principle）

* 思想：对扩展开放，对修改关闭。
* 描述：当需求发生变化时，应通过新增代码来扩展系统的行为，而不是修改已有的代码。这样可以避免影响已有功能，提高系统的稳定性。
* 优点：
    * 提高代码可维护性，降低因修改带来的风险。
    * 支持灵活的系统扩展，适应未来的变化。

#### 1.2 里氏代换原则（Liskov Substitution Principle）

* 思想：任何基类出现的地方都可以被其子类无缝替换，而不破坏程序的正确性。
* 描述：
    * 子类可以在不改变父类行为的前提下扩展功能。
    * 不允许覆盖父类的非抽象方法，以避免继承关系被破坏。
    * 子类可以添加自己的特有方法。
* 优点：
    * 提高程序的健壮性和可扩展性。
    * 保证继承结构的合理性，避免“强盗式”继承。

#### 1.3 依赖倒转原则（Dependence Inversion Principle）

* 思想：面向接口编程，而不是面向实现编程。
* 描述：
    * 高层模块不应该依赖低层模块，两者都应该依赖于抽象（接口或抽象类）。
    * 抽象不应依赖细节，细节应依赖于抽象。
* 优点：
    * 降低模块之间的耦合度。
    * 增加系统的灵活性和可测试性。

#### 1.4 接口隔离原则（Interface Segregation Principle）

* 思想：客户端不应该依赖它不需要的接口。
* 描述：
    * 一个类对另一个类的依赖应该建立在最小的接口上。
    * 应将臃肿的接口拆分为更细粒度的接口，以满足不同客户端的需求。
* 优点：
    * 避免接口污染，提高接口的内聚性。
    * 减少不必要的实现类代码冗余。

#### 1.5 迪米特法则（最少知道原则）（Demeter Principle）

* 思想：一个对象应当对其他对象保持最少的了解。
* 描述：
    * 只与直接的朋友通信（如成员变量、方法参数、返回值等）。
    * 不要和陌生人说话，即尽量减少与其他类的耦合。
* 优点：
    * 降低类之间的耦合度。
    * 提高系统的可维护性和可读性。

#### 1.6 单一职责原则（Principle of single responsibility）

* 思想：一个类/接口/方法只负责一项职责。
* 描述：
    * 每个类或接口应只有一个引起它变化的原因。
    * 职责划分清晰，有助于提高代码的可读性和可维护性。
* 优点：
    * 降低类的复杂度。
    * 提高可读性和可测试性。
    * 减少副作用和错误的发生概率。

## 2. 单例模式（[查看示例](./singleton_pattern)）

#### 2.1 饿汉模式（[查看示例](./singleton_pattern/Singleton1.java)）

* 饿汉模式，也叫静态常量模式，在类加载时就创建实例，实例对象是静态的，类加载时就完成实例化，线程安全，但无法实现延迟加载。
* 优点：
    * 实现简单：代码逻辑清晰，易于理解和实现。
    * 线程安全：由于实例在类加载时就创建好了，因此在多线程环境下使用是安全的，无需额外的同步控制。
* 缺点：
    * 资源浪费：如果该实例占用大量资源（如内存、IO等），而实际运行中又未使用到该实例，则会造成资源浪费。
    * 加载时机不可控：类在加载时就会创建实例，如果实例的创建过程比较耗时，会影响系统启动性能。

#### 2.2 懒汉模式（Lazy Initialization）

##### 2.2.1 非线程安全（[查看示例](./singleton_pattern/Singleton2.java)）

* 特点：首次使用时创建实例，未加同步控制，多线程环境下不安全。
* 优点：延迟加载，实现简单。
* 缺点：多线程可能创建多个实例。

##### 2.2.2 线程安全（加 synchronized）（[查看示例](./singleton_pattern/Singleton3.java)）

* 特点：通过 synchronized 保证线程安全，但性能较差。
* 优点：线程安全
* 缺点：每次调用 getInstance() 都需同步，性能下降。

#### 2.3 双重检查锁定（Double-Checked Locking）

##### 2.3.1 非线程安全 （[查看示例](./singleton_pattern/Singleton4.java)）

* 特点：首次使用时创建实例，未加同步控制，多线程环境下不安全。
* 优点：延迟加载，实现简单。
* 缺点：多线程可能创建多个实例。

##### 2.3.2 线程安全（加 volatile）（[查看示例](./singleton_pattern/Singleton5.java)）

* 特点：使用 volatile 禁止指令重排序，确保线程安全。
* 优点：线程安全 + 延迟加载 + 性能较好。

#### 2.4 静态内部类实现（推荐）（[查看示例](./singleton_pattern/Singleton6.java)）

* 特点：利用 JVM 类加载机制实现懒加载和线程安全。
* 优点：线程安全、延迟加载、性能高。

#### 2.5 枚举实现（推荐）（[查看示例](./singleton_pattern/Singleton7.java)）

* 特点：通过枚举实现单例，天然线程安全且防止反射攻击。
* 优点：简洁、线程安全、防止序列化/反射破坏单例。

## 3. 策略模式（[查看示例](./strategy_pattern)）

#### 3.1 基本策略模式（[查看示例](./strategy_pattern/base_strategy/BaseStrategyDemo.java)）

* 整体显得非常笨重不是很灵活，不推荐使用

#### 3.2 枚举策略模式（[查看示例](./strategy_pattern/enum_strategy/EnumStrategyPatternDemo.java)）

* 其具有代码简洁，线程安全，避免反射攻击，易于扩展的特点，但是灵活性受限，功能受限（策略逻辑复杂，枚举类可能会变得臃肿，不适合复杂的业务场景），复用性较差

#### 3.3 spring增强 策略模式（未实现）（[查看示例](./strategy_pattern/spring_enhance_strategy)）

* spring增强策略模式 相比基本策略模式更复杂，但它更适合大型项目或微服务架构中对可扩展性和可维护性要求较高的场景
* 使用场景
    * 多种支付方式（支付宝、微信、银联等）
    * 不同地区的促销策略
    * 多渠道消息发送（短信、邮件、站内信等）
    * 动态路由处理（根据请求参数决定执行逻辑）

## 4. 工厂模式（[查看示例](./factory_pattern))

#### 4.1 简单工厂模式（Simple Factory Pattern），也称为静态工厂方法模式（[查看示例](./factory_pattern/simple_factory/SimpleFactoryDemo.java))

* 简单工厂模式是一种创建型设计模式，它通过一个工厂类来统一创建对象的实例，从而解耦调用方与具体类之间的依赖关系。
* 核心结构：
    * 抽象产品（Product）：定义产品的公共接口或抽象类
    * 具体产品（Concrete Product）：抽象产品的具体实现
    * 工厂类（Factory）：包含一个静态方法，根据参数决定创建哪个具体产品
* 优点：
    * 解耦：调用方不依赖具体类，只依赖接口和工厂
    * 集中管理：所有对象创建逻辑集中在一个类中，便于维护
    * 易于扩展：新增类别只需修改工厂类（新增 case 分支）
* 缺点：
    * 违反开闭原则：新增类别需要修改工厂类，不符合“对修改关闭”
    * 工厂职责过重：所有创建逻辑都在一个类中，容易变得臃肿
    * 不属于GoF 23种设计模式：是一种简化版的工厂模式，不是标准模式

#### 4.2 工厂方法模式（Factory Method Pattern）（[查看示例](./factory_pattern/factory_method/FactoryMethodDemo.java)）

* 工厂方法模式是一种创建型设计模式，它通过定义抽象工厂类来创建抽象产品类的实例。抽象工厂类定义了创建抽象产品类的方法，而具体工厂类则实现了抽象工厂类中的方法，并返回具体产品类的实例。
* 核心结构:
    * 抽象产品（Product）：定义产品的公共接口或抽象类
    * 具体产品（Concrete Product）：产品的具体实现类
    * 抽象工厂（Factory）：定义工厂的公共接口或抽象类
    * 具体工厂（Concrete Factory）：工厂的具体实现类，继承抽象工厂类，并实现抽象工厂类中的方法，返回具体产品类的实例
* 优点：
    * 符合开闭原则：新增产品只需新增工厂类，无需修改已有代码
    * 解耦更彻底：每个工厂只负责一种产品，职责单一
    * 更具扩展性：支持多层级的产品族（如不同地区、不同类型的支付方式）
    * 更容易维护：各个工厂独立，便于测试和替换
* 缺点：
    * 类数量增加：每个产品都需要一个对应的工厂类，类数量成倍增长
    * 复杂度上升：对于简单场景来说，会略显复杂

#### 4.3 抽象工厂模式（Abstract Factory Pattern）（[查看示例](./factory_pattern/abstract_factory/AbstractFactoryDemo.java)）

* 抽象工厂模式是一种创建型设计模式
* 核心结构：
    * 抽象工厂（Abstract Factory）：定义一组用于创建产品的接口，如 CompanyFactory
    * 具体工厂（Concrete Factory）：实现抽象工厂的方法，返回具体产品实例，如 AppleCompanyFactory
    * 抽象产品（Abstract Product）：定义产品的公共接口，如 ComputerFactory, PhoneFactory
    * 具体产品（Concrete Product）：实现抽象产品的方法，具体产品实例，如 ApplePhoneProducer, MiComputerProducer
    * Client（客户端）：使用抽象工厂和抽象产品进行开发，不依赖具体实现
* 优点：
    * 封装性好：客户端不关心具体产品类，只需面向接口编程
    * 一致性保障：同一个工厂生产的系列产品保证兼容性和一致性
    * 易于扩展：新增一个品牌只需新增一个具体工厂类和具体产品类，符合开闭原则
    * 解耦：高层模块通过接口调用，不依赖具体实现类
* 缺点：
    * 复杂度高：涉及多个抽象接口和类，理解比较困难
    * 扩展困难：如新增一个新的产品类型（如耳机），必须修改抽象工厂接口，违反开闭原则

## 5 代理模式（[查看示例](./proxy_pattern)）

#### 5.1 静态代理模式（Static Proxy Pattern）（[查看示例](./proxy_pattern/static_proxy/StaticProxyDemo.java)）

* 静态代理模式通过手动编写代理类来对目标对象进行包装。
* 核心结构：
    * 公共接口（Subject）：定义目标对象和代理对象共同实现的接口，确保两者具有相同的行为。
    * 目标对象（RealSubject）：实现接口，完成具体的业务逻辑。
    * 代理对象（Proxy）：实现接口，内部持有目标对象的引用，在调用目标对象的方法前后，可以添加额外的控制逻辑。
* 优点：
    * 职责清晰：目标对象只关注业务逻辑，代理对象负责额外控制。
    * 增强功能：可以在不修改目标对象的情况下，为其添加日志、权限、缓存等功能。
    * 易于理解：结构清晰，适合简单场景。
* 缺点：
    * 扩展性差：如果接口方法很多，代理类需要为每个方法实现相同的代理逻辑，代码冗余。
    * 维护成本高：每增加一个目标类，就需要手动编写一个对应的代理类。

#### 5.2 动态代理模式（Dynamic Proxy Pattern）（[查看示例](./proxy_pattern/dynamic_proxy/DynamicProxyDemo.java)）

* 动态代理模式通过在运行时动态生成代理类，实现对目标对象的代理。
* 核心结构：
  * 运行时生成代理类：不需要手动编写代理类，由 JVM 在运行时动态生成。
  * 基于接口或类：支持两种实现方式：
    * JDK 动态代理：基于接口实现，要求目标类必须实现一个接口。
      * 公共接口（Subject）：定义目标对象和代理对象共同实现的接口。
      * 目标对象（RealSubject）：实现接口，完成具体的业务逻辑。
      * InvocationHandler：是代理实例的调用处理程序，负责定义代理逻辑。
    * CGLIB 动态代理：基于继承机制，通过生成子类来代理目标类（适用于没有实现接口的类）。
* 优点：
  * 高度灵活：无需为每个目标类手动编写代理类。
  * 统一处理逻辑：所有代理逻辑集中在 InvocationHandler 或 MethodInterceptor 中。
  * 符合开闭原则：新增目标类无需修改代理逻辑。
  * 解耦性好：业务逻辑与增强逻辑分离。
* 缺点：
  * 仅支持接口（JDK）：JDK 动态代理要求目标类必须实现接口（CGLIB 可解决此问题）。
  * 调试复杂：代理类是运行时生成的，调试时不易直接观察。
  * 性能开销：反射调用有一定性能损耗（但现代 JVM 已优化）。
